;;;
;;; Meta-definition of color space
;;; (currently not used)
;;;

(in-package :dufy-core)

(defstruct colorspace
  "illuminant::= illuminant | rgbspace | nil
clamp::= :always-clamped | :clampable | nil
"
  (term nil :type symbol)
  (args nil :type list)
  (arg-types nil :type list)
  (illuminant 'illuminant :type symbol)
  (clamp nil :type symbol)
  (neighbors nil :type list))

(defparameter *colorspace-table* (make-hash-table))

(defun colorspace= (space1 space2)
  (eql (colorspace-term space1)
       (colorspace-term space2)))

(defmacro define-colorspace (term args &key (illuminant :illuminant) clamp)
  (let ((key (make-keyword term)))
    `(setf (gethash ',key *colorspace-table*)
           (make-colorspace :term ',(make-keyword key)
                            :args ',(mapcar #'(lambda (x)
                                                (if (consp x)
                                                    (first x)
                                                    x))
                                            args)
                            :arg-types ',(mapcar #'(lambda (x)
                                                     (if (consp x)
                                                         (second x)
                                                         t))
                                                 args)
                            :illuminant ,illuminant
                            :clamp ,clamp
                            :neighbors nil))))

(defun get-colorspace (term)
  (gethash term *colorspace-table*))
(defun get-neighbors (term)
  (colorspace-neighbors (gethash term *colorspace-table*)))
(defun get-args (term)
  (colorspace-args (gethash term *colorspace-table*)))
(defun get-arg-types (term)
  (colorspace-arg-types (gethash term *colorspace-table*)))
(defun get-clamp (term)
  (colorspace-clamp (gethash term *colorspace-table*)))
(defun get-illuminant (term)
  (colorspace-illuminant (gethash term *colorspace-table*)))

(defun print-colorspace-table ()
  (format t "#<HASH-TABLE ~%")
  (maphash-values #'(lambda (val) (format t "~S~%" val))
                  *colorspace-table*)
  (format t ">~%"))

(defun add-primary-converter (from-term to-term &optional (bidirectional t))
  (let ((from-space (get-colorspace from-term))
        (to-space (get-colorspace to-term)))
    (assert (and from-space to-space))
    (pushnew to-term (colorspace-neighbors from-space))
    (when bidirectional
      (pushnew from-term (colorspace-neighbors to-space)))))


(defstruct queue list tail)
(defun enqueue (obj queue)
  (with-slots (list tail) queue
    (if (null list)
        (setf tail (list obj)
              list tail)
        (setf (cdr tail) (list obj)
              tail (cdr tail))))
  queue)
(defun dequeue (queue)
  (pop (queue-list queue)))

(defun get-converter-chain (begin-term dest-term)
  "Returns the shortest path in the converter graph with BFS."
  (let ((visited (make-hash-table))
        (path-q (enqueue (list begin-term) (make-queue))))
    (loop for path = (dequeue path-q)
          for current-term = (car path)
          do (when (null current-term)
               (error "No route found: from ~S to ~S" begin-term dest-term))
             (if (eql current-term dest-term)
                 (return (reverse path))
                 (unless (nth-value 1 (ensure-gethash current-term visited t))
                   (dolist (term (get-neighbors current-term))
                     (enqueue (cons term path) path-q)))))))


(define-colorspace xyz ((x double-float)
                        (y double-float)
                        (z double-float)))
(define-colorspace xyy ((small-x double-float)
                        (small-y double-float)
                        (y double-float)))
(define-colorspace lab ((lstar double-float)
                        (astar double-float)
                        (bstar double-float)))
(define-colorspace lchab ((lstar double-foat)
                          (cstarab double-float)
                          (hab double-float)))
(define-colorspace luv ((lstar double-float)
                        (ustar double-float)
                        (vstar double-float)))
(define-colorspace lchuv ((lstar double-float)
                          (cstaruv double-float)
                          (huv double-float)))
(define-colorspace rgb ((r double-float)
                        (g double-float)
                        (b double-float))
  :illuminant :rgbspace)
(define-colorspace lrgb ((lr double-float)
                         (lg double-float)
                         (lb double-float))
  :illuminant :rgbspace)
(define-colorspace qrgb ((qr integer)
                         (qg integer)
                         (qb integer))
  :illuminant :rgbspace :clamp :clampable)
(define-colorspace int ((int integer))
  :illuminant :rgbspace :clamp :always-clamped)
(define-colorspace hsv ((hue double-float)
                        (sat double-float)
                        (val double-float))
  :illuminant :rgbspace)
(define-colorspace hsl ((hue double-float)
                        (sat double-float)
                        (lum double-float))
  :illuminant :rgbspace)
(define-colorspace spectrum ((spectrum spectrum-function)))
(define-colorspace lms ((l double-float)
                        (m double-float)
                        (s double-float)))

;; (add-primary-converter :xyz :xyy)
;; (add-primary-converter :xyz :lms)
;; (add-primary-converter :xyz :spectrum)
;; (add-primary-converter :xyz :lrgb)
;; (add-primary-converter :lrgb :rgb)
;; (add-primary-converter :rgb :qrgb)
;; (add-primary-converter :qrgb :int)
;; (add-primary-converter :xyz :lab)
;; (add-primary-converter :lab :lchab)
;; (add-primary-converter :xyz :luv)
;; (add-primary-converter :luv :lchuv)
;; (add-primary-converter :hsv :rgb)
;; (add-primary-converter :hsl :rgb)


(defun gen-converter-name (from-term to-term)
  (intern (format nil "~A-TO-~A" from-term to-term) *package*))

(defmacro define-primary-converter (begin-term dest-term args &body body)
  "Defines FOO-TOO-BAR function as a primary converter."
  (let* ((begin-key (make-keyword begin-term))
         (dest-key (make-keyword dest-term))
         (fname (gen-converter-name begin-key dest-key)))
    `(progn
       (declaim (inline ,fname)
                (ftype (function * (values ,@(get-arg-types dest-key) &optional))))
       (defun ,fname ,args
         ,@body)
       (add-primary-converter ,begin-key ,dest-key nil))))

(defun converter-clamp-p (term1 term2)
  (and (not (eql (get-clamp term1) :always-clamped))
       (eql (get-clamp term2) :clampable)))

(defun get-local-illuminant-key (term1 term2)
  (let ((illum-key1 (get-illuminant term1))
        (illum-key2 (get-illuminant term2)))
    (cond ((or (eql illum-key1 :rgbspace) (eql illum-key2 :rgbspace))
           :rgbspace)
          ((or (eql illum-key1 :illuminant) (eql illum-key2 :illuminant))
           :illuminant)
          (t nil))))

(defun gen-global-key-args (term1 term2)
  (let ((key-args nil))
    (when (converter-clamp-p term1 term2)
      (push '(clamp t) key-args))
    key-args))

(defun gen-last-key-args (term1 term2)
  (let ((key-args nil))
    (when (converter-clamp-p term1 term2)
      (push :clamp key-args))
    key-args))

(defun expand-key-args (arg-lst)
  (mappend #'(lambda (key)
               (list key (intern (symbol-name key))))
           arg-lst))

(defmacro defconverter (begin-term dest-term)
  (let* ((global-fname (gen-converter-name begin-term dest-term))
         (chain (get-converter-chain begin-term dest-term))
         (global-key-args (gen-global-key-args begin-term dest-term))
         (last-key-args (gen-last-key-args begin-term dest-term)))
    (labels ((expand (term-lst code)
               (let* ((term1 (first term-lst))
                      (term2 (second term-lst))
                      (name (gen-converter-name term1 term2)))
                 (cond ((null (cdr term-lst)) code)
                       ((null code)
                        (expand (cdr term-lst)
                                `(,name ,@(get-args term1))))
                       ((eql term2 dest-term)
                        (expand (cdr term-lst)
                                `(multiple-value-call #',name
                                   ,code
                                   ,@(expand-key-args last-key-args))))
                       (t (expand (cdr term-lst)
                                  `(multiple-value-call #',name
                                     ,code)))))))
      `(progn
         (declaim (inline ,global-fname))
         (defun ,global-fname (,@(get-args begin-term)
                               &key ,@global-key-args)
           (declare (optimize (speed 3) (safety 1)))
           ,(expand chain nil))))))
