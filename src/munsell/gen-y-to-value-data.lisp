;;; This is a script file which generates fundamental data and saves them as a .lisp file.

(eval-when (:compile-toplevel :load-toplevel :execute)
  (asdf:load-system :alexandria))


(defparameter base-dir-path (make-pathname :directory (pathname-directory *load-pathname*)))
(defparameter src-dir-path (asdf:component-pathname (asdf:find-component (asdf:find-system :dufy-munsell) :munsell)))
(defparameter dat-dir-path (asdf:component-pathname (asdf:find-component (asdf:find-system :dufy) :dat)))
(defparameter obj-name "y-to-value-data.lisp")
(defparameter obj-path (merge-pathnames (pathname obj-name) src-dir-path))


;; convert munsell value to Y in [0, 1]
(defun munsell-value-to-y (v)
  (* v (+ 1.1914d0 (* v (+ -0.22533d0 (* v (+ 0.23352d0 (* v (+ -0.020484d0 (* v 0.00081939d0)))))))) 0.01d0))

(defun root-finding (func rhs a b threshold)
  (let* ((mid (* 0.5d0 (+ a b)))
	 (lhs (funcall func mid))
	 (delta (abs (- lhs rhs))))
    (if (<= delta threshold)
	mid
	(if (> lhs rhs)
	    (root-finding func rhs a mid threshold)
	    (root-finding func rhs mid b threshold)))))

(defparameter y-to-munsell-value-arr (make-array 1001 :element-type 'double-float :initial-element 0.0d0))

(setf (aref y-to-munsell-value-arr 0) 0.0d0)
(setf (aref y-to-munsell-value-arr 1000) 10.0d0)
(loop for y from 1 to 999 do
  (setf (aref y-to-munsell-value-arr y)
	(root-finding #'munsell-value-to-y (* y 0.001d0) 0 10 1.0d-6)))

;; y should be in [0,1]
(defun y-to-munsell-value (y)
  (let* ((y1000 (* (alexandria:clamp y 0 1) 1000))
	 (y1 (floor y1000))
	 (y2 (ceiling y1000)))
    (if (= y1 y2)
	(aref y-to-munsell-value-arr y1)
	(let ((r (- y1000 y1)))
	  (+ (* (- 1 r) (aref y-to-munsell-value-arr y1))
	     (* r (aref y-to-munsell-value-arr y2)))))))



(defun array-to-list (array)
  (let* ((dimensions (array-dimensions array))
         (depth      (1- (length dimensions)))
         (indices    (make-list (1+ depth) :initial-element 0)))
    (labels ((recurse (n)
               (loop for j below (nth n dimensions)
                     do (setf (nth n indices) j)
                     collect (if (= n depth)
                                 (apply #'aref array indices)
                               (recurse (1+ n))))))
      (recurse 0))))

(defun print-make-array (var-name array &optional (stream t) (declaration t))
  (let ((typ (array-element-type array))
	(dims (array-dimensions array)))
    (when declaration
      (prin1 `(declaim (type (simple-array ,typ ,dims)
			     ,(intern (string-upcase var-name))))
	     stream)
      (terpri stream))
    (format stream "(defparameter ~a ~% #." var-name)
    (prin1 `(make-array (quote ,dims)
			:element-type (quote ,typ)
			:initial-contents (quote ,(array-to-list array)))
	   stream)
    (princ ")" stream)
    (terpri stream)))

(with-open-file (out obj-path
		     :direction :output
		     :if-exists :supersede)
  (format out ";;; This file is automatically generated by ~a.~%~%"
	  (file-namestring *load-pathname*))
  (format out "(in-package :dufy.munsell)~%~%")
  (print-make-array "y-to-munsell-value-arr" y-to-munsell-value-arr out))

(format t "The file is saved at ~A~%" obj-path)
