;;; This is a script file which generates fundamental data and saves them as a .lisp file.

(require :alexandria)

(defparameter data-filename "fundamental-data.lisp")
(defparameter data-pathname (merge-pathnames data-filename *load-pathname*))


(defparameter color-matching-arr
  (make-array '(471 3) :element-type 'double-float :initial-element 0d0))

(with-open-file (in
		 (merge-pathnames #P"cie1931-color-matching.dat" *load-pathname*)
		 :direction :input)
  (let ((*read-default-float-format* 'double-float)
	(idx -1)
	(sub-idx 0))
    (loop
       for node = (read in nil :EOF)
       until (eq node :EOF)
       do
	 (if (integerp node)
	     (progn
	       (setf sub-idx 0)
	       (incf idx))
	     (progn
	       (setf (aref color-matching-arr idx sub-idx) node)
	       (incf sub-idx))))))



;; convert munsell value to Y in [0, 1]
(defun munsell-value-to-y (v)
  (* v (+ 1.1914d0 (* v (+ -0.22533d0 (* v (+ 0.23352d0 (* v (+ -0.020484d0 (* v 0.00081939d0)))))))) 0.01d0))

(defun root-finding (func rhs a b threshold)
  (let* ((mid (* 0.5d0 (+ a b)))
	 (lhs (funcall func mid))
	 (delta (abs (- lhs rhs))))
    (if (<= delta threshold)
	mid
	(if (> lhs rhs)
	    (root-finding func rhs a mid threshold)
	    (root-finding func rhs mid b threshold)))))

(defparameter y-to-munsell-value-arr (make-array 1001 :element-type 'double-float :initial-element 0.0d0))

(setf (aref y-to-munsell-value-arr 0) 0.0d0)
(setf (aref y-to-munsell-value-arr 1000) 10.0d0)
(loop for y from 1 to 999 do
  (setf (aref y-to-munsell-value-arr y)
	(root-finding #'munsell-value-to-y (* y 0.001d0) 0 10 1.0d-6)))

;; y should be in [0,1]
(defun y-to-munsell-value (y)
  (let* ((y1000 (* (alexandria:clamp y 0 1) 1000))
	 (y1 (floor y1000))
	 (y2 (ceiling y1000)))
    (if (= y1 y2)
	(aref y-to-munsell-value-arr y1)
	(let ((r (- y1000 y1)))
	  (+ (* (- 1 r) (aref y-to-munsell-value-arr y1))
	     (* r (aref y-to-munsell-value-arr y2)))))))



(defun array-to-list (array)
  (let* ((dimensions (array-dimensions array))
         (depth      (1- (length dimensions)))
         (indices    (make-list (1+ depth) :initial-element 0)))
    (labels ((recurse (n)
               (loop for j below (nth n dimensions)
                     do (setf (nth n indices) j)
                     collect (if (= n depth)
                                 (apply #'aref array indices)
                               (recurse (1+ n))))))
      (recurse 0))))

(defun print-make-array (var-name array &optional (stream t))
  (let ((typ (array-element-type array))
	(dims (array-dimensions array)))
    (format stream "(defparameter ~a ~% #." var-name)
    (prin1 `(make-array (quote ,dims)
			:element-type (quote ,typ)
			:initial-contents (quote ,(array-to-list array)))
	   stream)
    (princ ")" stream)
    (terpri stream)))


(with-open-file (out data-pathname
		     :direction :output
		     :if-exists :supersede)
  (format out ";;; This file is automatically generated by ~a.~%~%"
	  (file-namestring *load-pathname*))
  (format out "(in-package :dufy)~%~%")
  (print-make-array "color-matching-arr" color-matching-arr out)
  (print-make-array "y-to-munsell-value-arr" y-to-munsell-value-arr out))

(format t "The file is saved at ~A~%" data-pathname)
